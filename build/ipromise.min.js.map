{"version":3,"sources":["ipromise.js"],"names":["exports","handle","promise","onFulfilled","onRejected","isFunction","_FCallbacks","push","_RCallbacks","thenable","x","t","then","resolve","reject","TypeError","constructor","iPromise","_state","PENDING","val","reason","FULFILLED","fulfill","_value","REJECTED","done","call","y","r","e","value","setTimeout","i","len","length","splice","error","resolver","this","err","toString","Object","prototype","obj","prtt","oldPromise","all","promises","accumulator","ready","race","onlyOne","window"],"mappings":"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","file":"ipromise.min.js","sourcesContent":["/*/\r\n/// author: zcoding\r\n/// version: 0.1.0\r\n/// repository: https://github.com/zcoding/spa-promise.git\r\n/*/\r\n\r\n(function(exports) {\r\n\nvar toString = Object.prototype.toString,\r\n  isFunction = function(obj) {\r\n    return toString.call(obj) === '[object Function]';\r\n  },\r\n  FULFILLED = 1,\r\n  REJECTED = 2,\r\n  PENDING = 0;\r\n\r\n/**\r\n * handle a callback\r\n * @param {iPromise} promise\r\n * @param {Function} onFulfilled\r\n * @param {Function} onRejected\r\n */\r\nfunction handle(promise, onFulfilled, onRejected) {\r\n  if (isFunction(onFulfilled)) {\r\n    promise._FCallbacks.push(onFulfilled);\r\n  }\r\n  if (isFunction(onRejected)) {\r\n    promise._RCallbacks.push(onRejected);\r\n  }\r\n}\r\n\r\nfunction thenable(x) {\r\n  var t = typeof x;\r\n  if (x && (t === 'object' || t === 'function') && typeof x.then === 'function') {\r\n    return x.then;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * promise resolution procedure\r\n * @param {iPromise} promise\r\n * @param {Object} x\r\n * TODO: async bug\r\n */\r\nfunction resolve(promise, x) {\r\n  if (promise === x) {\r\n    reject(promise, new TypeError('The promise and its value refer to the same object.'));\r\n  } else if (x && x.constructor === iPromise) {\r\n    if (x._state === PENDING) {\r\n\t\t\tx.then(function (val) {\r\n\t\t\t\tresolve(promise, val);\r\n\t\t\t}, function (reason) {\r\n\t\t\t\treject(promise, reason);\r\n\t\t\t})\r\n\t\t}\r\n\t\telse if (x._state === FULFILLED) {\r\n\t\t\tfulfill(promise, x._value);\r\n\t\t}\r\n\t\telse if (x._state === REJECTED) {\r\n\t\t\treject(promise, x._value);\r\n\t\t}\r\n  } else {\r\n    var done = false; // 保证只调用一次\r\n    try {\r\n      var then = thenable(x);\r\n      if (then) { // thenable\r\n        then.call(x, function(y) {\r\n          done || resolve(promise, y);\r\n          done = true;\r\n        }, function(r) {\r\n          done || reject(promise, r);\r\n          done = true;\r\n        });\r\n      } else {\r\n        fulfill(promise, x);\r\n      }\r\n    } catch (e) {\r\n      done || reject(promise, e);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * change the status to `FULFILLED` and invoke callbacks\r\n * @param {iPromise} promise\r\n * @param {Object} value\r\n */\r\nfunction fulfill(promise, value) {\r\n  if (promise._state !== PENDING) {\r\n\t\treturn;\r\n\t}\r\n  promise._state = FULFILLED;\r\n  promise._value = value;\r\n  setTimeout(function() {\r\n    for (var i = 0, len = promise._FCallbacks.length; i < len; ++i) {\r\n      promise._FCallbacks[i].call(null, value);\r\n    }\r\n    promise._FCallbacks.splice(0); // once fufilled, empty callback queue\r\n  }, 0);\r\n}\r\n\r\n/**\r\n * change the status to `REJECTED` and invoke callbacks\r\n * @param {iPromise} promise\r\n * @param {Obejct} error\r\n */\r\nfunction reject(promise, error) {\r\n  if (promise._state !== PENDING) {\r\n\t\treturn;\r\n\t}\r\n  promise._state = REJECTED;\r\n  promise._value = error;\r\n  setTimeout(function() {\r\n    for (var i = 0, len = promise._RCallbacks.length; i < len; ++i) {\r\n      promise._RCallbacks[i].call(null, error);\r\n    }\r\n    promise._RCallbacks.splice(0); // once rejected, empty callback queue\r\n  }, 0);\r\n}\r\n\r\n/**\r\n * @class iPromise\r\n * @param {Function} resolver\r\n * @constructor\r\n */\r\nfunction iPromise(resolver) {\r\n\r\n  this._state = PENDING;\r\n  this._value = null;\r\n  this._FCallbacks = []; // FULFILLED callback queue\r\n  this._RCallbacks = []; // REJECTED callback queue\r\n\r\n  var promise = this;\r\n\r\n  try {\r\n    resolver(function(value) {\r\n      resolve(promise, value);\r\n    }, function(error) {\r\n      reject(promise, error);\r\n    });\r\n  } catch(err) {\r\n    reject(promise, err);\r\n  }\r\n\r\n}\r\n\r\nvar prtt = iPromise.prototype;\r\n\r\n/**\r\n * .then(onFulfilled, onRejected)\r\n * @method\r\n * @param {Function} onFulfilled\r\n * @param {Function} onRejected\r\n * @return {iPromise} always return a new Promsie\r\n */\r\nprtt.then = function(onFulfilled, onRejected) {\r\n  var oldPromise = this;\r\n  return new iPromise(function(resolve, reject) {\r\n    handle(oldPromise, function(value) { // pending until old promise is resolved or rejected\r\n      if (isFunction(onFulfilled)) {\r\n        try {\r\n          resolve(onFulfilled(value));\r\n        } catch (error) {\r\n          reject(error);\r\n        }\r\n      } else {\r\n        resolve(value);\r\n      }\r\n    }, function(reason) {\r\n      if (isFunction(onRejected)) {\r\n        try {\r\n          resolve(onRejected(reason));\r\n        } catch (error) {\r\n          reject(error);\r\n        }\r\n      } else {\r\n        reject(reason);\r\n      }\r\n    });\r\n  });\r\n\r\n};\r\n\r\n/**\r\n * .catch(onRejected)\r\n * @method\r\n * @param {Function} onRejected\r\n * @return {iPromsie} always return a new Promise\r\n */\r\nprtt.catch = function(onRejected) {\r\n  return this.then(null, onRejected);\r\n};\r\n\r\n/**\r\n * .resolve(value)\r\n * @static\r\n * @param {Object} value\r\n * @return {iPromise}\r\n */\r\niPromise.resolve = function(value) {\r\n  return new iPromise(function(resolve, reject) {\r\n    resolve(value);\r\n  });\r\n};\r\n\r\n/**\r\n * .reject(error)\r\n * @static reject\r\n * @param {Object} error\r\n * @return {iPromise}\r\n */\r\niPromise.reject = function(error) {\r\n  return new iPromise(function(resolve, reject) {\r\n    reject(error);\r\n  });\r\n};\r\n\r\n/**\r\n * .all(promises)\r\n * @static\r\n * @param {Array} promises\r\n * @return {iPromise}\r\n */\r\niPromise.all = function(promises) {\r\n  var accumulator = [];\r\n  var ready = iPromise.resolve(null);\r\n  for (var i = 0, len = promises.length; i < len; ++i) {\r\n    var promise = promises[i];\r\n    ready = ready.then(function() {\r\n      return promise;\r\n    }).then(function(value) {\r\n      accumulator.push(value);\r\n    });\r\n  }\r\n  return ready.then(function() {\r\n    return accumulator;\r\n  });\r\n};\r\n\r\n/**\r\n * .race(promises)\r\n * @static\r\n * @param {Array} promises\r\n * @return {iPromise}\r\n */\r\niPromise.race = function(promises) {\r\n  return new iPromise(function(resolve, reject) {\r\n    var onlyOne = true;\r\n    for (var i = 0, len = promises.length; i < len; ++i) {\r\n      var promise = promises[i];\r\n      promise.then(function(value) {\r\n        if (onlyOne) {\r\n          onlyOne = false;\r\n          resolve(value);\r\n        }\r\n      }, function(error) {\r\n        if (onlyOne) {\r\n          onlyOne = false;\r\n          reject(error);\r\n        }\r\n      });\r\n    }\r\n  });\r\n};\r\n\r\nexports.iPromise = iPromise;\r\n\n})(window);\r\n"],"sourceRoot":"/source/"}